use crate::events::{Payload, SyntaxEvent, Terminal};
use crate::syntax::SyntaxKind;
use crate::tokens::{TokenCollection, TokenKind};

/// Parse tokens and return a list of syntax events indicating
/// scopes of specific productions.
///
/// This function takes tokens collection generated by `lex()` function
/// as well as the starting rule. After all tokens are parsed this
/// function returns flat collection of `SyntaxEvent`. Each event may
/// mark either start or end of specific syntax rule, or point to the
/// terminal(token) included in such rule (sometimes with an error
/// message if syntax error was met).
///
/// * `tokens`: reference to tokens collection returned by `lex()`
///   function
/// * `start`: rule that should act as a entry point of the parsing
///   process
pub fn parse(tokens: &TokenCollection, start: SyntaxKind) -> Vec<SyntaxEvent> {
    let mut p = Parser::new(tokens);
    match start {
        SyntaxKind::StoredDefinition => stored_definition(&mut p),
        SyntaxKind::ClassDefinition => class_definition(&mut p),
        SyntaxKind::ClassPrefixes => class_prefixes(&mut p),
        SyntaxKind::ClassSpecifier => class_specifier(&mut p),
        SyntaxKind::LongClassSpecifier => long_class_specifier(&mut p),
        SyntaxKind::ShortClassSpecifier => short_class_specifier(&mut p),
        SyntaxKind::DerClassSpecifier => der_class_specifier(&mut p),
        SyntaxKind::BasePrefix => base_prefix(&mut p),
        SyntaxKind::EnumList => enum_list(&mut p),
        SyntaxKind::EnumerationLiteral => enumeration_literal(&mut p),
        SyntaxKind::Composition => composition(&mut p),
        SyntaxKind::LanguageSpecification => language_specification(&mut p),
        SyntaxKind::ExternalFunctionCall => external_function_call(&mut p),
        SyntaxKind::ElementList => element_list(&mut p),
        SyntaxKind::Element => element(&mut p),
        SyntaxKind::ImportClause => import_clause(&mut p),
        SyntaxKind::ImportList => import_list(&mut p),
        SyntaxKind::ExtendsClause => extends_clause(&mut p),
        SyntaxKind::ConstrainingClause => constraining_clause(&mut p),
        SyntaxKind::ClassOrInheritanceModification => class_or_inheritance_modification(&mut p),
        SyntaxKind::ArgumentOrInheritanceModificationList => {
            argument_or_inheritance_modification_list(&mut p)
        }
        SyntaxKind::InheritanceModification => inheritance_modification(&mut p),
        SyntaxKind::ComponentClause => component_clause(&mut p),
        SyntaxKind::TypePrefix => type_prefix(&mut p),
        SyntaxKind::ComponentList => component_list(&mut p),
        SyntaxKind::ComponentDeclaration => component_declaration(&mut p),
        SyntaxKind::ConditionAttribute => condition_attribute(&mut p),
        SyntaxKind::Declaration => declaration(&mut p),
        SyntaxKind::Modification => modification(&mut p),
        SyntaxKind::ModificationExpression => modification_expression(&mut p),
        SyntaxKind::ClassModification => class_modification(&mut p),
        SyntaxKind::ArgumentList => argument_list(&mut p),
        SyntaxKind::Argument => argument(&mut p),
        SyntaxKind::ElementModificationOrReplaceable => element_modification_or_replaceable(&mut p),
        SyntaxKind::ElementModification => element_modification(&mut p),
        SyntaxKind::ElementRedeclaration => element_redeclaration(&mut p),
        SyntaxKind::ElementReplaceable => element_replaceable(&mut p),
        SyntaxKind::ComponentClause1 => component_clause1(&mut p),
        SyntaxKind::ComponentDeclaration1 => component_declaration1(&mut p),
        SyntaxKind::ShortClassDefinition => short_class_definition(&mut p),
        SyntaxKind::EquationSection => equation_section(&mut p),
        SyntaxKind::AlgorithmSection => algorithm_section(&mut p),
        SyntaxKind::Equation => equation(&mut p),
        SyntaxKind::Statement => statement(&mut p),
        SyntaxKind::IfEquation => if_equation(&mut p),
        SyntaxKind::IfStatement => if_statement(&mut p),
        SyntaxKind::ForEquation => for_equation(&mut p),
        SyntaxKind::ForStatement => for_statement(&mut p),
        SyntaxKind::ForIndices => for_indices(&mut p),
        SyntaxKind::ForIndex => for_index(&mut p),
        SyntaxKind::WhileStatement => while_statement(&mut p),
        SyntaxKind::WhenEquation => when_equation(&mut p),
        SyntaxKind::WhenStatement => when_statement(&mut p),
        SyntaxKind::ConnectEquation => connect_equation(&mut p),
        SyntaxKind::Expression => expression(&mut p),
        SyntaxKind::SimpleExpression => simple_expression(&mut p),
        SyntaxKind::LogicalExpression => logical_expression(&mut p),
        SyntaxKind::LogicalTerm => logical_term(&mut p),
        SyntaxKind::LogicalFactor => logical_factor(&mut p),
        SyntaxKind::Relation => relation(&mut p),
        SyntaxKind::RelationalOperator => relational_operator(&mut p),
        SyntaxKind::ArithmeticExpression => arithmetic_expression(&mut p),
        SyntaxKind::AddOperator => add_operator(&mut p),
        SyntaxKind::Term => term(&mut p),
        SyntaxKind::MulOperator => mul_operator(&mut p),
        SyntaxKind::Factor => factor(&mut p),
        SyntaxKind::Primary => primary(&mut p),
        SyntaxKind::TypeSpecifier => type_specifier(&mut p),
        SyntaxKind::Name => name(&mut p),
        SyntaxKind::ComponentReference => component_reference(&mut p),
        SyntaxKind::ResultReference => result_reference(&mut p),
        SyntaxKind::FunctionCallArgs => function_call_args(&mut p),
        SyntaxKind::FunctionArguments => function_arguments(&mut p),
        SyntaxKind::FunctionArgumentsNonFirst => function_arguments_non_first(&mut p),
        SyntaxKind::ArrayArguments => array_arguments(&mut p),
        SyntaxKind::ArrayArgumentsNonFirst => array_arguments_non_first(&mut p),
        SyntaxKind::NamedArguments => named_arguments(&mut p),
        SyntaxKind::NamedArgument => named_argument(&mut p),
        SyntaxKind::FunctionArgument => function_argument(&mut p),
        SyntaxKind::FunctionPartialApplication => function_partial_application(&mut p),
        SyntaxKind::OutputExpressionList => output_expression_list(&mut p),
        SyntaxKind::ExpressionList => expression_list(&mut p),
        SyntaxKind::ArraySubscripts => array_subscripts(&mut p),
        SyntaxKind::Subscript => subscript(&mut p),
        SyntaxKind::Description => description(&mut p),
        SyntaxKind::DescriptionString => description_string(&mut p),
        SyntaxKind::AnnotationClause => annotation_clause(&mut p),
        SyntaxKind::Error => (),
    }
    p.events
}

/// Represents a Modelica parser
struct Parser<'a> {
    /// Scanned tokens
    tokens: &'a TokenCollection,
    /// Collected syntax events
    events: Vec<SyntaxEvent>,
    /// Current position in the `TokenCollection`
    pos: usize,
}

impl<'a> Parser<'a> {
    /// Return a new parser instance
    fn new(tokens: &'a TokenCollection) -> Self {
        let cap = tokens.len();
        Parser {
            tokens,
            events: Vec::with_capacity(cap),
            pos: 0,
        }
    }

    /// Return the vector position where the grammar rule starts. Push a
    /// new `SyntaxEvent` into the vector.
    ///
    /// Assume that rule is erroneous. It is updated during `exit()`.
    fn enter(&mut self) -> usize {
        let mark = self.events.len();
        let p = Payload {
            typ: SyntaxKind::Error,
            tok: self.pos,
            pair: self.events.len(),
        };
        self.events.push(SyntaxEvent::Enter(p));
        mark
    }

    /// Close the production scope and update its type
    ///
    /// * `m`: position of the corresponding enter event
    /// * `typ`: type of the production
    fn exit(&mut self, m: usize, typ: SyntaxKind) {
        let mark = self.events.len();
        match &mut self.events[m] {
            SyntaxEvent::Enter(ref mut p) => {
                p.typ = typ;
                p.pair = mark;
            }
            _ => unreachable!(),
        }
        match self.events.last().unwrap() {
            SyntaxEvent::Enter(..) => _ = self.events.pop(),
            SyntaxEvent::Exit(p) => {
                self.events.push(SyntaxEvent::Exit(Payload {
                    typ,
                    tok: p.tok,
                    pair: m,
                }));
            }
            _ => {
                self.events.push(SyntaxEvent::Exit(Payload {
                    typ,
                    tok: self.pos - 1,
                    pair: m,
                }));
            }
        }
    }

    /// Advance the parser, consume the token and push it into the events vector
    fn advance(&mut self) {
        if !self.eof() {
            self.events
                .push(SyntaxEvent::Advance(Terminal::Token(self.pos)));
            self.pos += 1;
        }
    }

    /// Return `true` if parser reached the end of file
    fn eof(&self) -> bool {
        self.pos == self.tokens.token_count()
    }

    /// Return type of the n-th token counting from the current one.
    fn nth(&self, n: usize) -> TokenKind {
        self.tokens
            .get_token(self.pos + n)
            .map_or(TokenKind::EOF, |tok| tok.typ)
    }

    /// Return `true` if current token matches the specified type
    fn check(&self, typ: TokenKind) -> bool {
        self.nth(0) == typ
    }

    /// Return `true` if current token matches any of the specified types
    fn check_any(&self, typ: &[TokenKind]) -> bool {
        typ.contains(&self.nth(0))
    }

    /// Return `true` if current token matches the specified type and
    /// advance the parser. Otherwise return `false` and do not advance.
    fn consume(&mut self, typ: TokenKind) -> bool {
        if self.check(typ) {
            self.advance();
            return true;
        }
        false
    }

    /// Mark currently parsed token as erroneus.
    fn error(&mut self, msg: String) {
        let mark = self.enter();
        if !self.eof() {
            self.events
                .push(SyntaxEvent::Advance(Terminal::Error { msg, tok: self.pos }));
            self.pos += 1;
        }
        self.exit(mark, SyntaxKind::Error);
    }

    /// Advance the parser if current token is expected. Report error if
    /// current tokens doesn't match the specified type.
    fn expect(&mut self, typ: TokenKind) {
        if !self.consume(typ) {
            self.error(format!("expected '{typ:?}', found '{:?}'", self.nth(0)));
        }
    }
}

// Useful constants used in the parsing process

const SECTION_BREAKERS: [TokenKind; 8] = [
    TokenKind::Protected,
    TokenKind::Public,
    TokenKind::Initial,
    TokenKind::Equation,
    TokenKind::Algorithm,
    TokenKind::End,
    TokenKind::Annotation,
    TokenKind::External,
];
const CLASS_PREFS: [TokenKind; 13] = [
    TokenKind::Partial,
    TokenKind::Class,
    TokenKind::Model,
    TokenKind::Record,
    TokenKind::Function,
    TokenKind::Block,
    TokenKind::Type,
    TokenKind::Operator,
    TokenKind::Connector,
    TokenKind::Package,
    TokenKind::Pure,
    TokenKind::Impure,
    TokenKind::Expandable,
];

// Those functions implement syntax specification from
// https://specification.modelica.org/maint/3.6/modelica-concrete-syntax.html

// A.2.1 Stored Definition – Within

fn stored_definition(p: &mut Parser) {
    let mark = p.enter();
    if p.consume(TokenKind::Within) {
        if !p.check(TokenKind::Semi) {
            name(p);
        }
        p.expect(TokenKind::Semi);
    }
    while !p.eof() {
        p.consume(TokenKind::Final);
        class_definition(p);
        p.expect(TokenKind::Semi);
    }
    p.exit(mark, SyntaxKind::StoredDefinition);
}

// A.2.2 Class Definition

fn class_definition(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Encapsulated);
    class_prefixes(p);
    class_specifier(p);
    p.exit(mark, SyntaxKind::ClassDefinition);
}

fn class_prefixes(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Partial);
    let pref = p.nth(0);
    match pref {
        TokenKind::Class
        | TokenKind::Model
        | TokenKind::Block
        | TokenKind::Type
        | TokenKind::Package
        | TokenKind::Record
        | TokenKind::Connector
        | TokenKind::Function => {
            p.advance();
        }
        TokenKind::Expandable => {
            p.advance();
            p.expect(TokenKind::Connector);
        }
        TokenKind::Operator => {
            p.advance();
            if !p.consume(TokenKind::Record) {
                p.consume(TokenKind::Function);
            }
        }
        TokenKind::Pure | TokenKind::Impure => {
            p.advance();
            p.consume(TokenKind::Operator);
            p.expect(TokenKind::Function);
        }
        _ => p.error(format!(
            "unexpected token '{:?}' used as a class prefix",
            p.nth(0)
        )),
    }
    p.exit(mark, SyntaxKind::ClassPrefixes);
}

fn class_specifier(p: &mut Parser) {
    let mark = p.enter();
    if p.check(TokenKind::Extends) {
        long_class_specifier(p);
    } else if p.check(TokenKind::Ident) {
        if p.nth(1) != TokenKind::Equal {
            long_class_specifier(p);
        } else if p.nth(2) == TokenKind::Der {
            der_class_specifier(p);
        } else {
            short_class_specifier(p);
        }
    } else {
        p.error(format!(
            "unexpected token '{:?}': doesn't match any type of class specifier",
            p.nth(0)
        ));
    }
    p.exit(mark, SyntaxKind::ClassSpecifier);
}

fn long_class_specifier(p: &mut Parser) {
    let mark = p.enter();
    if p.consume(TokenKind::Extends) {
        p.expect(TokenKind::Ident);
        if p.check(TokenKind::LParen) {
            class_modification(p);
        }
    } else {
        p.expect(TokenKind::Ident);
    }
    description_string(p);
    composition(p);
    p.expect(TokenKind::End);
    p.expect(TokenKind::Ident);
    p.exit(mark, SyntaxKind::LongClassSpecifier);
}

fn short_class_specifier(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    p.expect(TokenKind::Equal);
    if p.consume(TokenKind::Enumeration) {
        p.expect(TokenKind::LParen);
        if !p.consume(TokenKind::Colon) && p.check(TokenKind::Ident) {
            enum_list(p);
        }
        p.expect(TokenKind::RParen);
    } else {
        base_prefix(p);
        type_specifier(p);
        if p.check(TokenKind::LBracket) {
            array_subscripts(p);
        }
        if p.check(TokenKind::LParen) {
            class_modification(p);
        }
    }
    description(p);
    p.exit(mark, SyntaxKind::ShortClassSpecifier);
}

fn der_class_specifier(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    p.expect(TokenKind::Equal);
    p.expect(TokenKind::Der);
    p.expect(TokenKind::LParen);
    type_specifier(p);
    p.expect(TokenKind::Comma);
    p.expect(TokenKind::Ident);
    while !p.consume(TokenKind::RParen) && !p.eof() {
        p.expect(TokenKind::Comma);
        p.expect(TokenKind::Ident);
    }
    description(p);
    p.exit(mark, SyntaxKind::DerClassSpecifier);
}

fn base_prefix(p: &mut Parser) {
    let mark = p.enter();
    if !p.consume(TokenKind::Input) {
        p.consume(TokenKind::Output);
    }
    p.exit(mark, SyntaxKind::BasePrefix);
}

fn enum_list(p: &mut Parser) {
    let mark = p.enter();
    enumeration_literal(p);
    while !p.check(TokenKind::RParen) && !p.eof() {
        p.expect(TokenKind::Comma);
        enumeration_literal(p);
    }
    p.exit(mark, SyntaxKind::EnumList);
}

fn enumeration_literal(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    description(p);
    p.exit(mark, SyntaxKind::EnumerationLiteral);
}

fn composition(p: &mut Parser) {
    let mark = p.enter();
    element_list(p);
    while !p.check_any(&[TokenKind::External, TokenKind::Annotation, TokenKind::End]) && !p.eof() {
        let k = p.nth(0);
        match k {
            TokenKind::Public | TokenKind::Protected => {
                p.advance();
                element_list(p);
            }
            TokenKind::Initial => match p.nth(1) {
                TokenKind::Equation => {
                    equation_section(p);
                }
                TokenKind::Algorithm => {
                    algorithm_section(p);
                }
                _ => p.error(format!("unexpected token '{:?}' following 'initial'. Expected 'equation' or 'algorithm'", p.nth(1))),
            },
            TokenKind::Equation => {
                equation_section(p);
            }
            TokenKind::Algorithm => {
                algorithm_section(p);
            }
            _ => p.error(format!("unexpected token '{:?}' after element list inside composition. Expected 'protected', 'public', 'initial', 'equation', 'algorithm', 'external', 'annotation' or 'end'.", p.nth(0))),
        }
    }
    if p.consume(TokenKind::External) {
        if p.check(TokenKind::String) {
            language_specification(p);
        }
        if p.check_any(&[TokenKind::Dot, TokenKind::Ident]) {
            external_function_call(p);
        }
        if p.check(TokenKind::Annotation) {
            annotation_clause(p);
        }
        p.expect(TokenKind::Semi);
    }
    if p.check(TokenKind::Annotation) {
        annotation_clause(p);
        p.expect(TokenKind::Semi);
    }
    p.exit(mark, SyntaxKind::Composition);
}

fn language_specification(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::String);
    p.exit(mark, SyntaxKind::LanguageSpecification);
}

fn external_function_call(p: &mut Parser) {
    let mark = p.enter();
    if p.nth(1) != TokenKind::LParen {
        component_reference(p);
        p.expect(TokenKind::Equal);
    }
    p.expect(TokenKind::Ident);
    p.expect(TokenKind::LParen);
    if !p.check(TokenKind::RParen) {
        expression_list(p);
    }
    p.expect(TokenKind::RParen);
    p.exit(mark, SyntaxKind::ExternalFunctionCall);
}

fn element_list(p: &mut Parser) {
    let mark = p.enter();
    while !p.check_any(&SECTION_BREAKERS) && !p.eof() {
        element(p);
        p.expect(TokenKind::Semi);
    }
    p.exit(mark, SyntaxKind::ElementList);
}

fn element(p: &mut Parser) {
    let mark = p.enter();
    if p.check(TokenKind::Import) {
        import_clause(p);
    } else if p.check(TokenKind::Extends) {
        extends_clause(p);
    } else {
        p.consume(TokenKind::Redeclare);
        p.consume(TokenKind::Final);
        p.consume(TokenKind::Inner);
        p.consume(TokenKind::Outer);
        if p.consume(TokenKind::Replaceable) {
            if p.check_any(&CLASS_PREFS) || p.check(TokenKind::Encapsulated) {
                class_definition(p);
            } else {
                component_clause(p);
            }
            if p.check(TokenKind::Constrainedby) {
                constraining_clause(p);
                description(p);
            }
        } else if p.check_any(&CLASS_PREFS) || p.check(TokenKind::Encapsulated) {
            class_definition(p);
        } else {
            component_clause(p);
        }
    }
    p.exit(mark, SyntaxKind::Element);
}

fn import_clause(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Import);
    if p.nth(1) == TokenKind::Equal {
        p.expect(TokenKind::Ident);
        p.advance();
        name(p);
    } else {
        name(p);
        if !p.consume(TokenKind::DotStar) && p.consume(TokenKind::Dot) {
            p.expect(TokenKind::LCurly);
            import_list(p);
            p.expect(TokenKind::RCurly);
        }
    }
    description(p);
    p.exit(mark, SyntaxKind::ImportClause);
}

fn import_list(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    while p.consume(TokenKind::Comma) && !p.eof() {
        p.expect(TokenKind::Ident);
    }
    p.exit(mark, SyntaxKind::ImportList);
}

// A.2.3 Extends

fn extends_clause(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Extends);
    type_specifier(p);
    if p.check(TokenKind::LParen) {
        class_or_inheritance_modification(p);
    }
    if p.check(TokenKind::Annotation) {
        annotation_clause(p);
    }
    p.exit(mark, SyntaxKind::ExtendsClause);
}

fn constraining_clause(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Constrainedby);
    type_specifier(p);
    if p.check(TokenKind::LParen) {
        class_modification(p);
    }
    p.exit(mark, SyntaxKind::ConstrainingClause);
}

fn class_or_inheritance_modification(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::LParen);
    if !p.consume(TokenKind::RParen) {
        argument_or_inheritance_modification_list(p);
        p.expect(TokenKind::RParen);
    }
    p.exit(mark, SyntaxKind::ClassOrInheritanceModification);
}

fn argument_or_inheritance_modification_list(p: &mut Parser) {
    let mark = p.enter();
    if p.check(TokenKind::Break) {
        inheritance_modification(p);
    } else {
        argument(p);
    }
    while p.consume(TokenKind::Comma) && !p.eof() {
        if p.check(TokenKind::Break) {
            inheritance_modification(p);
        } else {
            argument(p);
        }
    }
    p.exit(mark, SyntaxKind::ArgumentOrInheritanceModificationList);
}

fn inheritance_modification(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Break);
    if p.check(TokenKind::Connect) {
        connect_equation(p);
    } else {
        p.expect(TokenKind::Ident);
    }
    p.exit(mark, SyntaxKind::InheritanceModification);
}

// A.2.4 Component Clause

fn component_clause(p: &mut Parser) {
    let mark = p.enter();
    type_prefix(p);
    type_specifier(p);
    if p.check(TokenKind::LBracket) {
        array_subscripts(p);
    }
    component_list(p);
    p.exit(mark, SyntaxKind::ComponentClause);
}

fn type_prefix(p: &mut Parser) {
    let mark = p.enter();
    if !p.consume(TokenKind::Flow) {
        p.consume(TokenKind::Stream);
    }
    if !p.consume(TokenKind::Discrete) && !p.consume(TokenKind::Parameter) {
        p.consume(TokenKind::Constant);
    }
    if !p.consume(TokenKind::Input) {
        p.consume(TokenKind::Output);
    }
    p.exit(mark, SyntaxKind::TypePrefix);
}

fn component_list(p: &mut Parser) {
    let mark = p.enter();
    component_declaration(p);
    while p.consume(TokenKind::Comma) && !p.eof() {
        component_declaration(p);
    }
    p.exit(mark, SyntaxKind::ComponentList);
}

fn component_declaration(p: &mut Parser) {
    let mark = p.enter();
    declaration(p);
    if p.check(TokenKind::If) {
        condition_attribute(p);
    }
    description(p);
    p.exit(mark, SyntaxKind::ComponentDeclaration);
}

fn condition_attribute(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::If);
    expression(p);
    p.exit(mark, SyntaxKind::ConditionAttribute);
}

fn declaration(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    if p.check(TokenKind::LBracket) {
        array_subscripts(p);
    }
    if p.check_any(&[TokenKind::LParen, TokenKind::Equal, TokenKind::Assign]) {
        modification(p);
    }
    p.exit(mark, SyntaxKind::Declaration);
}

// A.2.5 Modification

fn modification(p: &mut Parser) {
    let mark = p.enter();
    if p.check_any(&[TokenKind::Equal, TokenKind::Assign]) {
        p.advance();
        modification_expression(p);
    } else {
        class_modification(p);
        if p.consume(TokenKind::Equal) {
            modification_expression(p);
        }
    }
    p.exit(mark, SyntaxKind::Modification);
}

fn modification_expression(p: &mut Parser) {
    let mark = p.enter();
    if !p.consume(TokenKind::Break) {
        expression(p);
    }
    p.exit(mark, SyntaxKind::ModificationExpression);
}

fn class_modification(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::LParen);
    if !p.consume(TokenKind::RParen) {
        argument_list(p);
        p.expect(TokenKind::RParen);
    }
    p.exit(mark, SyntaxKind::ClassModification);
}

fn argument_list(p: &mut Parser) {
    let mark = p.enter();
    argument(p);
    while p.consume(TokenKind::Comma) && !p.eof() {
        argument(p);
    }
    p.exit(mark, SyntaxKind::ArgumentList);
}

fn argument(p: &mut Parser) {
    let mark = p.enter();
    if p.check(TokenKind::Redeclare) {
        element_redeclaration(p);
    } else {
        element_modification_or_replaceable(p);
    }
    p.exit(mark, SyntaxKind::Argument);
}

fn element_modification_or_replaceable(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Each);
    p.consume(TokenKind::Final);
    if p.check(TokenKind::Replaceable) {
        element_replaceable(p);
    } else {
        element_modification(p);
    }
    p.exit(mark, SyntaxKind::ElementModificationOrReplaceable);
}

fn element_modification(p: &mut Parser) {
    let mark = p.enter();
    name(p);
    if p.check_any(&[TokenKind::LParen, TokenKind::Equal, TokenKind::Assign]) {
        modification(p);
    }
    description_string(p);
    p.exit(mark, SyntaxKind::ElementModification);
}

fn element_redeclaration(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Redeclare);
    p.consume(TokenKind::Each);
    p.consume(TokenKind::Final);
    if p.check_any(&CLASS_PREFS) {
        short_class_definition(p);
    } else if p.check(TokenKind::Replaceable) {
        element_replaceable(p);
    } else {
        component_clause1(p);
    }
    p.exit(mark, SyntaxKind::ElementReplaceable);
}

fn element_replaceable(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Replaceable);
    if p.check_any(&CLASS_PREFS) {
        short_class_definition(p);
    } else {
        component_clause1(p);
    }
    if p.check(TokenKind::Constrainedby) {
        constraining_clause(p);
    }
    p.exit(mark, SyntaxKind::ElementReplaceable);
}

fn component_clause1(p: &mut Parser) {
    let mark = p.enter();
    type_prefix(p);
    type_specifier(p);
    component_declaration1(p);
    p.exit(mark, SyntaxKind::ComponentClause1);
}

fn component_declaration1(p: &mut Parser) {
    let mark = p.enter();
    declaration(p);
    description(p);
    p.exit(mark, SyntaxKind::ComponentDeclaration1);
}

fn short_class_definition(p: &mut Parser) {
    let mark = p.enter();
    class_prefixes(p);
    short_class_specifier(p);
    p.exit(mark, SyntaxKind::ShortClassDefinition);
}

// A.2.6 Equations

fn equation_section(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Initial);
    p.expect(TokenKind::Equation);
    while !p.check_any(&SECTION_BREAKERS) && !p.eof() {
        equation(p);
        p.expect(TokenKind::Semi);
    }
    p.exit(mark, SyntaxKind::EquationSection);
}

fn algorithm_section(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Initial);
    p.expect(TokenKind::Algorithm);
    while !p.check_any(&SECTION_BREAKERS) && !p.eof() {
        statement(p);
        p.expect(TokenKind::Semi);
    }
    p.exit(mark, SyntaxKind::AlgorithmSection);
}

fn equation(p: &mut Parser) {
    let mark = p.enter();
    match p.nth(0) {
        TokenKind::If => if_equation(p),
        TokenKind::For => for_equation(p),
        TokenKind::When => when_equation(p),
        TokenKind::Connect => connect_equation(p),
        _ => {
            // FIXME: It is somewhat simplified for now. Specification
            // allows only `component-reference func-call-args`, so not
            // every `simple-expression` that is not followed by the `=`
            // can be accepted
            simple_expression(p);
            if p.consume(TokenKind::Equal) {
                expression(p);
            }
        }
    }
    description(p);
    p.exit(mark, SyntaxKind::Equation);
}

fn statement(p: &mut Parser) {
    let mark = p.enter();
    match p.nth(0) {
        TokenKind::If => if_statement(p),
        TokenKind::For => for_statement(p),
        TokenKind::While => while_statement(p),
        TokenKind::When => when_statement(p),
        TokenKind::Break | TokenKind::Return => p.advance(),
        TokenKind::LParen => {
            p.advance();
            output_expression_list(p);
            p.expect(TokenKind::RParen);
            p.expect(TokenKind::Assign);
            component_reference(p);
            function_call_args(p);
        }
        _ => {
            component_reference(p);
            if p.consume(TokenKind::Assign) {
                expression(p);
            } else {
                function_call_args(p);
            }
        }
    }
    description(p);
    p.exit(mark, SyntaxKind::Statement);
}

fn if_equation(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::If);
    expression(p);
    p.expect(TokenKind::Then);
    while !p.check_any(&[TokenKind::Elif, TokenKind::Else, TokenKind::End]) && !p.eof() {
        equation(p);
        p.expect(TokenKind::Semi);
    }
    while !p.check_any(&[TokenKind::Else, TokenKind::End]) & !p.eof() {
        p.expect(TokenKind::Elif);
        expression(p);
        p.expect(TokenKind::Then);
        while !p.check_any(&[TokenKind::Elif, TokenKind::Else, TokenKind::End]) && !p.eof() {
            equation(p);
            p.expect(TokenKind::Semi);
        }
    }
    if p.consume(TokenKind::Else) {
        while !p.check(TokenKind::End) && !p.eof() {
            equation(p);
            p.expect(TokenKind::Semi);
        }
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::If);
    p.exit(mark, SyntaxKind::IfEquation);
}

fn if_statement(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::If);
    expression(p);
    p.expect(TokenKind::Then);
    while !p.check_any(&[TokenKind::Elif, TokenKind::Else, TokenKind::End]) && !p.eof() {
        statement(p);
        p.expect(TokenKind::Semi);
    }
    while !p.check_any(&[TokenKind::Else, TokenKind::End]) & !p.eof() {
        p.expect(TokenKind::Elif);
        expression(p);
        p.expect(TokenKind::Then);
        while !p.check_any(&[TokenKind::Elif, TokenKind::Else, TokenKind::End]) && !p.eof() {
            statement(p);
            p.expect(TokenKind::Semi);
        }
    }
    if p.consume(TokenKind::Else) {
        while !p.check(TokenKind::End) && !p.eof() {
            statement(p);
            p.expect(TokenKind::Semi);
        }
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::If);
    p.exit(mark, SyntaxKind::IfStatement);
}

fn for_equation(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::For);
    for_indices(p);
    p.expect(TokenKind::Loop);
    while !p.check(TokenKind::End) && !p.eof() {
        equation(p);
        p.expect(TokenKind::Semi);
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::For);
    p.exit(mark, SyntaxKind::ForEquation);
}

fn for_statement(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::For);
    for_indices(p);
    p.expect(TokenKind::Loop);
    while !p.check(TokenKind::End) && !p.eof() {
        statement(p);
        p.expect(TokenKind::Semi);
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::For);
    p.exit(mark, SyntaxKind::ForStatement);
}

fn for_indices(p: &mut Parser) {
    let mark = p.enter();
    for_index(p);
    while p.consume(TokenKind::Comma) && !p.eof() {
        for_index(p);
    }
    p.exit(mark, SyntaxKind::ForIndices);
}

fn for_index(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    if p.consume(TokenKind::In) {
        expression(p);
    }
    p.exit(mark, SyntaxKind::ForIndex);
}

fn while_statement(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::While);
    expression(p);
    p.expect(TokenKind::Loop);
    while !p.check(TokenKind::End) && !p.eof() {
        statement(p);
        p.expect(TokenKind::Semi);
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::While);
    p.exit(mark, SyntaxKind::WhenStatement);
}

fn when_equation(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::When);
    expression(p);
    p.expect(TokenKind::Then);
    while !p.check_any(&[TokenKind::Elwhen, TokenKind::End]) && !p.eof() {
        equation(p);
        p.expect(TokenKind::Semi);
    }
    while !p.check(TokenKind::End) & !p.eof() {
        p.expect(TokenKind::Elwhen);
        expression(p);
        p.expect(TokenKind::Then);
        while !p.check_any(&[TokenKind::Elwhen, TokenKind::End]) && !p.eof() {
            equation(p);
            p.expect(TokenKind::Semi);
        }
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::When);
    p.exit(mark, SyntaxKind::WhenEquation);
}

fn when_statement(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::When);
    expression(p);
    p.expect(TokenKind::Then);
    while !p.check_any(&[TokenKind::Elwhen, TokenKind::End]) && !p.eof() {
        statement(p);
        p.expect(TokenKind::Semi);
    }
    while !p.check(TokenKind::End) & !p.eof() {
        p.expect(TokenKind::Elwhen);
        expression(p);
        p.expect(TokenKind::Then);
        while !p.check_any(&[TokenKind::Elwhen, TokenKind::End]) && !p.eof() {
            statement(p);
            p.expect(TokenKind::Semi);
        }
    }
    p.expect(TokenKind::End);
    p.expect(TokenKind::When);
    p.exit(mark, SyntaxKind::WhenStatement);
}

fn connect_equation(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Connect);
    p.expect(TokenKind::LParen);
    component_reference(p);
    p.expect(TokenKind::Comma);
    component_reference(p);
    p.expect(TokenKind::RParen);
    p.exit(mark, SyntaxKind::ConnectEquation);
}

// A.2.7 Expressions

fn expression(p: &mut Parser) {
    let mark = p.enter();
    match p.nth(0) {
        TokenKind::If => {
            p.advance();
            expression(p);
            p.expect(TokenKind::Then);
            expression(p);
            while !p.check(TokenKind::Else) && !p.eof() {
                p.expect(TokenKind::Elif);
                expression(p);
                p.expect(TokenKind::Then);
                expression(p);
            }
            p.expect(TokenKind::Else);
            expression(p);
        }
        _ => simple_expression(p),
    }
    p.exit(mark, SyntaxKind::Expression);
}

fn simple_expression(p: &mut Parser) {
    let mark = p.enter();
    logical_expression(p);
    if p.consume(TokenKind::Colon) {
        logical_expression(p);
        if p.consume(TokenKind::Colon) {
            logical_expression(p);
        }
    }
    p.exit(mark, SyntaxKind::SimpleExpression);
}

fn logical_expression(p: &mut Parser) {
    let mark = p.enter();
    logical_term(p);
    while p.consume(TokenKind::Or) && !p.eof() {
        logical_term(p);
    }
    p.exit(mark, SyntaxKind::LogicalExpression);
}

fn logical_term(p: &mut Parser) {
    let mark = p.enter();
    logical_factor(p);
    while p.consume(TokenKind::And) && !p.eof() {
        logical_factor(p);
    }
    p.exit(mark, SyntaxKind::LogicalTerm);
}

fn logical_factor(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Not);
    relation(p);
    p.exit(mark, SyntaxKind::LogicalFactor);
}

fn relation(p: &mut Parser) {
    const RELOPS: [TokenKind; 6] = [
        TokenKind::Les,
        TokenKind::Leq,
        TokenKind::Gre,
        TokenKind::Geq,
        TokenKind::Eq,
        TokenKind::Neq,
    ];
    let mark = p.enter();
    arithmetic_expression(p);
    if p.check_any(&RELOPS) {
        relational_operator(p);
        arithmetic_expression(p);
    }
    p.exit(mark, SyntaxKind::Relation);
}

fn relational_operator(p: &mut Parser) {
    let mark = p.enter();
    // It is only called in `relation`, which already does the checking,
    // so no need to check token once again
    p.advance();
    p.exit(mark, SyntaxKind::RelationalOperator);
}

fn arithmetic_expression(p: &mut Parser) {
    const ADDOPS: [TokenKind; 4] = [
        TokenKind::Plus,
        TokenKind::DotPlus,
        TokenKind::Minus,
        TokenKind::DotMinus,
    ];
    let mark = p.enter();
    if p.check_any(&ADDOPS) {
        add_operator(p);
    }
    term(p);
    while p.check_any(&ADDOPS) && !p.eof() {
        add_operator(p);
        term(p);
    }
    p.exit(mark, SyntaxKind::ArithmeticExpression);
}

fn add_operator(p: &mut Parser) {
    let mark = p.enter();
    // It is only called in `arithmetic_expression`, which already does the checking,
    // so no need to check token once again
    p.advance();
    p.exit(mark, SyntaxKind::AddOperator);
}

fn term(p: &mut Parser) {
    const MULOPS: [TokenKind; 4] = [
        TokenKind::Star,
        TokenKind::DotStar,
        TokenKind::Slash,
        TokenKind::DotSlash,
    ];
    let mark = p.enter();
    factor(p);
    while p.check_any(&MULOPS) && !p.eof() {
        mul_operator(p);
        factor(p);
    }
    p.exit(mark, SyntaxKind::Term);
}

fn mul_operator(p: &mut Parser) {
    let mark = p.enter();
    // It is only called in `term`, which already does the checking,
    // so no need to check token once again
    p.advance();
    p.exit(mark, SyntaxKind::MulOperator);
}

fn factor(p: &mut Parser) {
    let mark = p.enter();
    primary(p);
    if p.check_any(&[TokenKind::Flex, TokenKind::DotFlex]) {
        p.advance();
        primary(p);
    }
    p.exit(mark, SyntaxKind::Factor);
}

fn primary(p: &mut Parser) {
    let mark = p.enter();
    match p.nth(0) {
        TokenKind::Ureal
        | TokenKind::Uint
        | TokenKind::String
        | TokenKind::True
        | TokenKind::False
        | TokenKind::End => p.advance(),
        TokenKind::LParen => {
            p.advance();
            output_expression_list(p);
            p.expect(TokenKind::RParen);
        }
        TokenKind::LBracket => {
            p.advance();
            expression_list(p);
            while p.consume(TokenKind::Semi) && !p.eof() {
                expression_list(p);
            }
            p.expect(TokenKind::RBracket);
        }
        TokenKind::LCurly => {
            p.advance();
            array_arguments(p);
            p.expect(TokenKind::RCurly);
        }
        TokenKind::Der | TokenKind::Initial | TokenKind::Pure => {
            p.advance();
            function_call_args(p);
        }
        _ => {
            component_reference(p);
            if p.check(TokenKind::LParen) {
                function_call_args(p);
            }
        }
    }
    p.exit(mark, SyntaxKind::Primary);
}

fn type_specifier(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Dot);
    name(p);
    p.exit(mark, SyntaxKind::TypeSpecifier);
}

fn name(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    while p.consume(TokenKind::Dot) && !p.eof() {
        p.expect(TokenKind::Ident);
    }
    p.exit(mark, SyntaxKind::Name);
}

fn component_reference(p: &mut Parser) {
    let mark = p.enter();
    p.consume(TokenKind::Dot);
    p.expect(TokenKind::Ident);
    if p.check(TokenKind::LBracket) {
        array_subscripts(p);
    }
    while p.consume(TokenKind::Dot) && !p.eof() {
        p.expect(TokenKind::Ident);
        if p.check(TokenKind::LBracket) {
            array_subscripts(p);
        }
    }
    p.exit(mark, SyntaxKind::ComponentReference);
}

fn result_reference(p: &mut Parser) {
    let mark = p.enter();
    if p.consume(TokenKind::Der) {
        p.expect(TokenKind::LParen);
        component_reference(p);
        if p.consume(TokenKind::Comma) {
            p.expect(TokenKind::Uint);
        }
        p.expect(TokenKind::RParen);
    } else {
        component_reference(p);
    }
    p.exit(mark, SyntaxKind::ResultReference);
}

fn function_call_args(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::LParen);
    if !p.consume(TokenKind::RParen) {
        function_arguments(p);
        p.expect(TokenKind::RParen);
    }
    p.exit(mark, SyntaxKind::FunctionCallArgs);
}

fn function_arguments(p: &mut Parser) {
    let mark = p.enter();
    if p.nth(1) == TokenKind::Equal {
        named_arguments(p);
    } else if !p.check(TokenKind::Function) {
        expression(p);
        if p.consume(TokenKind::Comma) {
            function_arguments_non_first(p);
        } else if p.consume(TokenKind::For) {
            for_indices(p);
        }
    } else {
        function_partial_application(p);
        if p.consume(TokenKind::Comma) {
            function_arguments_non_first(p);
        }
    }
    p.exit(mark, SyntaxKind::FunctionArguments);
}

fn function_arguments_non_first(p: &mut Parser) {
    let mark = p.enter();
    if p.nth(1) == TokenKind::Equal {
        named_arguments(p);
    } else {
        function_argument(p);
        if p.consume(TokenKind::Comma) {
            function_arguments_non_first(p);
        }
    }
    p.exit(mark, SyntaxKind::FunctionArgumentsNonFirst);
}

fn array_arguments(p: &mut Parser) {
    let mark = p.enter();
    expression(p);
    if p.consume(TokenKind::Comma) {
        array_arguments_non_first(p);
    } else if p.consume(TokenKind::For) {
        for_indices(p);
    }
    p.exit(mark, SyntaxKind::ArrayArguments);
}

fn array_arguments_non_first(p: &mut Parser) {
    let mark = p.enter();
    expression(p);
    if p.consume(TokenKind::Comma) {
        array_arguments_non_first(p);
    }
    p.exit(mark, SyntaxKind::ArrayArgumentsNonFirst);
}

fn named_arguments(p: &mut Parser) {
    let mark = p.enter();
    named_argument(p);
    if p.consume(TokenKind::Comma) {
        named_arguments(p);
    }
    p.exit(mark, SyntaxKind::NamedArguments);
}

fn named_argument(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Ident);
    p.expect(TokenKind::Equal);
    function_argument(p);
    p.exit(mark, SyntaxKind::NamedArgument);
}

fn function_argument(p: &mut Parser) {
    let mark = p.enter();
    if p.check(TokenKind::Function) {
        function_partial_application(p);
    } else {
        expression(p);
    }
    p.exit(mark, SyntaxKind::FunctionArgument);
}

fn function_partial_application(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Function);
    type_specifier(p);
    p.expect(TokenKind::LParen);
    if p.check(TokenKind::Ident) {
        named_arguments(p);
    }
    p.expect(TokenKind::RParen);
    p.exit(mark, SyntaxKind::FunctionPartialApplication);
}

fn output_expression_list(p: &mut Parser) {
    let mark = p.enter();
    // This production can only occur inside parentheses, so easiest way
    // is to check for right paren
    if !p.check(TokenKind::RParen) {
        // At least one expression is there
        expression(p);
        while p.consume(TokenKind::Comma) && !p.eof() {
            if !p.check_any(&[TokenKind::RParen, TokenKind::Comma]) {
                expression(p);
            }
        }
    }
    p.exit(mark, SyntaxKind::OutputExpressionList);
}

fn expression_list(p: &mut Parser) {
    let mark = p.enter();
    expression(p);
    while p.consume(TokenKind::Comma) && !p.eof() {
        expression(p);
    }
    p.exit(mark, SyntaxKind::ExpressionList);
}

fn array_subscripts(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::LBracket);
    subscript(p);
    while p.consume(TokenKind::Comma) && !p.eof() {
        subscript(p);
    }
    p.expect(TokenKind::RBracket);
    p.exit(mark, SyntaxKind::ArraySubscripts);
}

fn subscript(p: &mut Parser) {
    let mark = p.enter();
    if !p.consume(TokenKind::Colon) {
        expression(p);
    }
    p.exit(mark, SyntaxKind::Subscript);
}

fn description(p: &mut Parser) {
    let mark = p.enter();
    description_string(p);
    if p.check(TokenKind::Annotation) {
        annotation_clause(p);
    }
    p.exit(mark, SyntaxKind::Description);
}

fn description_string(p: &mut Parser) {
    let mark = p.enter();
    if p.consume(TokenKind::String) {
        while p.consume(TokenKind::Plus) && !p.eof() {
            p.expect(TokenKind::String);
        }
    }
    p.exit(mark, SyntaxKind::DescriptionString);
}

fn annotation_clause(p: &mut Parser) {
    let mark = p.enter();
    p.expect(TokenKind::Annotation);
    class_modification(p);
    p.exit(mark, SyntaxKind::AnnotationClause);
}

#[cfg(test)]
mod tests {

    use super::*;
    use crate::lex;

    fn get_events(input: &str, entry: SyntaxKind) -> Vec<SyntaxEvent> {
        let tokens = lex(input);
        parse(&tokens, entry)
    }
    fn check_errors(events: &Vec<SyntaxEvent>) -> bool {
        let mut result = true;
        for event in events {
            match event {
                SyntaxEvent::Enter(p) => match p.typ {
                    SyntaxKind::Error => result = false,
                    _ => (),
                },
                _ => (),
            }
        }
        result
    }

    #[test]
    fn parse_expression() {
        let source: &str = "(-a) + 2 * foo(x ./ 2) ^ 3";
        let events = get_events(source, SyntaxKind::Expression);
        assert!(check_errors(&events));
        let source: &str = "if x ^ 2 > 2 then 2 elseif x ^ 2 < 2 and x >= 0 then -1 else 0";
        let events = get_events(source, SyntaxKind::Expression);
        assert!(check_errors(&events));
    }
    #[test]
    fn parse_primary() {
        let source: &str = "foo.bar(a=5)";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(check_errors(&events));
        let source: &str = "der(x)";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(check_errors(&events));
        // Output list
        let source: &str = "(x, , y, x + 5, )";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(check_errors(&events));
        // Matrix
        let source: &str = "[1, 2, 3; a, b, c; x, y, z]";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(check_errors(&events));
        // Arrays
        let source: &str = "{x * i for i in 1:n}";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(check_errors(&events));
        let source: &str = "{x + y, x, 1}";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(check_errors(&events));
        // Incorrect syntax
        let source: &str = "{x + y, x, 2 * i for i in 1:n}";
        let events = get_events(source, SyntaxKind::Primary);
        assert!(!check_errors(&events));
    }
    #[test]
    fn parse_component_reference() {
        let source: &str = "a";
        let events = get_events(source, SyntaxKind::ComponentReference);
        assert!(check_errors(&events));
        let source: &str = "foo.bar.baz";
        let events = get_events(source, SyntaxKind::ComponentReference);
        assert!(check_errors(&events));
        let source: &str = ".foo.bar";
        let events = get_events(source, SyntaxKind::ComponentReference);
        assert!(check_errors(&events));
        let source: &str = ".foo[1, 2].bar[3]";
        let events = get_events(source, SyntaxKind::ComponentReference);
        assert!(check_errors(&events));
        let source: &str = "foo[1, 2].bar[:, x].baz";
        let events = get_events(source, SyntaxKind::ComponentReference);
        assert!(check_errors(&events));
    }
    #[test]
    fn parse_function_call_args() {
        // Only named args
        let source: &str = "(a = 2, b = function .Foo.Bar(a = 5), c = x + y)";
        let events = get_events(source, SyntaxKind::FunctionCallArgs);
        assert!(check_errors(&events));
        // Correctly mixed args
        let source: &str = "(function .Foo.Bar(a = 5), 5, b = 3, c = x + y)";
        let events = get_events(source, SyntaxKind::FunctionCallArgs);
        assert!(check_errors(&events));
        // Incorrectly mixed args
        let source: &str = "(a = 2, 5, b = 3, c = x + y)";
        let events = get_events(source, SyntaxKind::FunctionCallArgs);
        assert!(!check_errors(&events));
    }
    #[test]
    fn parse_array_subscripts() {
        let source = "[i, i+1, :]";
        let events = get_events(source, SyntaxKind::ArraySubscripts);
        assert!(check_errors(&events));
    }
    #[test]
    fn parse_description() {
        const SOURCE1: &str = "\"Some text\" + \"and more text\" + \"and little more text\"";
        let tokens = lex(SOURCE1);
        let events = parse(&tokens, SyntaxKind::DescriptionString);
        assert_eq!(events.len(), 7);
        let source2: &str = &(String::from(SOURCE1)
            + " annotation (Dialog(tab = \"General\", group = \'General\"))");
        let tokens = lex(source2);
        let events = parse(&tokens, SyntaxKind::DescriptionString);
        assert!(check_errors(&events));
    }
}
